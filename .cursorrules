# .cursorrules

project: "DMOC Web (PWA)"
owner: "Digiwize"
description: >
Multi-tenant logistics operations app converted from Windows to web.
Each logistics client (Delta, Cobra, etc.) runs under Digiwize.
Uses MySQL, Prisma, Next.js, NestJS, Socket.IO, BullMQ, and MinIO.

## DEPLOYMENT STRATEGY - CRITICAL

**HYBRID APPROACH**: Vercel for development/testing, VPS for production delivery

- **Development**: Use Vercel for rapid iteration and testing
- **Production**: Deploy to VPS for full control and performance
- **Code**: Write VPS-compatible code that works on both platforms
- **Goal**: One-click VPS deployment when ready for production

### VPS-First Development Rules

- **Database**: Always use MySQL (not PostgreSQL) - VPS uses local MySQL
- **Storage**: Use S3/MinIO compatible APIs - VPS uses local MinIO
- **Background Jobs**: Design for BullMQ + Redis - VPS has persistent Redis
- **Real-time**: Use Socket.IO with persistent connections - VPS supports WebSockets
- **File Uploads**: Use multipart/form-data compatible with both platforms
- **Environment**: Support both Vercel env vars and VPS .env files
- **Timeouts**: Avoid long-running operations that exceed Vercel's 30s limit
- **Dependencies**: Choose libraries compatible with both serverless and VPS

### Platform Compatibility Checklist

Before implementing any feature, ensure it works on:

- ✅ **Vercel** (development/testing)
- ✅ **VPS** (production delivery)
- ✅ **Docker** (containerized deployment)

rules:

- Always comment the top of every code file with its relative path and purpose.
- Use modular folder structure under /apps/web and /apps/api.
- Enforce tenant isolation via tenant_id on every query.
- Global offender_registry visible only through backend logic, not client-to-client.
- Use Prisma ORM for all DB access (MySQL) - VPS uses local MySQL.
- Use Socket.IO for real-time manifest updates and WhatsApp/GPS feed.
- Use next-pwa and Dexie for offline PWA support.
- UI: Tailwind + shadcn + lucide-react; must respect tenant theme.
- Backend: NestJS + BullMQ + Redis + MinIO for media storage.
- ANPR uses YOLOv8 + PaddleOCR microservice (FastAPI).
- Biometrics uses InsightFace or DeepFace for selfie/ID match.
- Keep functions ≤ 60 lines; document logic and side effects.
- Digiwize admins can view all tenants; tenants can see only their data.
- Push updates through real-time sockets, not polling.
- Never expose raw ID numbers across tenants.
- When opening a PR, include the Linear issue ID in the branch name and PR title; summarize changes, risks, and test steps.

## Linear Integration - CRITICAL FOR AI CHATS

- **Workspace**: justwessels (https://linear.app/justwessels)
- **Team**: Justwessels (team ID: 39290bde-f690-4d61-94e3-439faf1892d1)
- **Project**: DMOC (dmoc-86db242489ad)
- **Issue Prefix**: JUS- (e.g., JUS-16, JUS-17)
- **Git Branch Format**: jjwprotozoa/jus-{issue-number}-{kebab-case-title}

### MCP Configuration for AI Chats

- **ALWAYS use team parameter**: `"justwessels"` (exactly this string, lowercase)
- **NEVER use**: "Justin's projects", "Justwessels", or "justins-projects-f7a019bf"
- **Team ID**: 39290bde-f690-4d61-94e3-439faf1892d1
- **Project**: dmoc (optional for project-specific issues)

### MCP Tool Usage Examples

```typescript
// ✅ CORRECT - List issues
mcp_Linear_list_issues({ team: 'justwessels', limit: 50 });

// ✅ CORRECT - Create issue
mcp_Linear_create_issue({ title: 'Title', team: 'justwessels', priority: 2 });

// ✅ CORRECT - Get team info
mcp_Linear_get_team({ query: 'justwessels' });
```

### Issue Management

- Always create Linear issues for significant changes, bug fixes, and new features
- Include Linear issue IDs in commit messages and changelog entries
- Use team "justwessels" (not "Justin's projects") when creating issues via MCP
- Reference LINEAR_CONFIG.md for complete MCP configuration details

## Changelog Management

- Maintain CHANGELOG.md using semantic versioning (MAJOR.MINOR.PATCH).
- Use automated changelog scripts: `npm run changelog:add`, `npm run changelog:version`, `npm run changelog:generate`.
- Update changelog for significant changes (features, fixes, security updates).
- Git hooks automatically check for changelog updates on commits.
- Version bumping: patch (bug fixes), minor (new features), major (breaking changes).
- Include Linear issue IDs in changelog entries when applicable.
- Follow Keep a Changelog format with categories: Added, Changed, Fixed, Security, Deprecated, Removed.

## Version Guidelines

- **MAJOR** (X.0.0): Breaking changes, major architectural changes, API changes
- **MINOR** (0.X.0): New features, significant improvements, new integrations
- **PATCH** (0.0.X): Bug fixes, minor improvements, documentation updates, dependency updates

## Changelog Entry Format

```markdown
### Added

- Feature description with context and impact
- Integration with external service X

### Changed

- Modified behavior description with migration notes
- Updated dependency X to version Y

### Fixed

- Bug fix description with affected components
- Performance improvement in component X

### Security

- Security fix description with CVE if applicable
- Updated authentication mechanism
```

## Automated Changelog Commands

- `npm run changelog:add <type> <description> [category]` - Add manual entry
- `npm run changelog:version [type] [version]` - Create new version section
- `npm run changelog:generate [since]` - Generate from git commits
- `npm run changelog:current` - Show current version
- `npm run version:patch|minor|major` - Quick version bumping

## Git Integration

- Pre-commit hook checks for changelog updates on significant changes
- Post-merge hook suggests generating changelog from commits
- Husky manages git hooks automatically
- Changelog updates are encouraged but not mandatory for small changes
